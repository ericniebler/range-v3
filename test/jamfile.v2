
#  Tests using Unit Test Library

# Copyright Pierre Talbot 2013.

# From Copyright 2005: Eric Niebler
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

import testing ;  # Bring in rules for testing
  
if ! $(BOOST_ROOT)
{
    BOOST_ROOT = [ modules.peek : BOOST_ROOT ] ;
}

project expected
    : requirements
      <include>. # .cpp files in expected/test.
      <include>../include/ # expected .hpp files.
      
      <link>static
      <toolset>gcc:<cxxflags>-std=c++11
      <toolset>gcc:<cxxflags>-Wno-unused-local-typedefs
      #<toolset>clang-3.5xl:<cxxflags>-Wunused-function
      #<toolset>clang-3.5xl:<cxxflags>-Wunneeded-internal-declaration
      <toolset>msvc:<asynch-exceptions>on # Needed for Boost.Test
      <toolset>msvc:<warnings>all
      <toolset>msvc:<define>_SCL_SECURE_NO_WARNINGS
      <toolset>msvc:<define>_SCL_SECURE_NO_DEPRECATE
      <toolset>msvc:<define>_CRT_SECURE_NO_DEPRECATE
      <toolset>msvc:<define>_CRT_SECURE_NO_WARNINGS

      # Warning suppression:
      <toolset>msvc:<cxxflags>/wd4100 # unreferenced formal parameter.

      <toolset>msvc:<iterator_debugging>off
      <toolset>intel-win:<iterator_debugging>off
    ;

test-suite general
    : 
      [ run range_adaptor.cpp  ]
      [ run range_facade.cpp  ]
      #[ run simple_test.cpp  ]
      #[ run test_iterarors.cpp  ]
      #[ run test_utils.cpp  ]
    ;

test-suite utility
    : 
      [ run utility/concepts.cpp  ]
      [ run utility/predicate.cpp  ]
    ;

test-suite algorithm
    : 
      [ run algorithm/adjacent_find.cpp  ]
      [ run algorithm/all_of.cpp  ]
      [ run algorithm/binary_search.cpp  ]
      [ run algorithm/copy.cpp  ]
      [ run algorithm/copy_backward.cpp  ]
      [ run algorithm/count.cpp  ]
      [ run algorithm/count_if.cpp  ]
      [ run algorithm/equal.cpp  ]
      [ run algorithm/equal_range.cpp  ]
      [ run algorithm/fill.cpp  ]
      [ run algorithm/find.cpp  ]
      [ run algorithm/find_end.cpp  ]
      [ run algorithm/find_first_of.cpp  ]
      [ run algorithm/find_if.cpp  ]
      [ run algorithm/for_each.cpp  ]
      [ run algorithm/generate.cpp  ]
      [ run algorithm/generate_n.cpp  ]
      [ run algorithm/lexicographical_compare.cpp  ]
      [ run algorithm/lower_bound.cpp  ]
      [ run algorithm/max_element.cpp  ]
      [ run algorithm/merge.cpp  ]
      [ run algorithm/min_element.cpp  ]
      [ run algorithm/minmax_element.cpp  ]
      [ run algorithm/mismatch.cpp  ]
      [ run algorithm/move.cpp : : : : algo_move  ]
      [ run algorithm/move_backward.cpp  ]
      [ run algorithm/nth_element.cpp  ]
      [ run algorithm/rotate.cpp  ]
      [ run algorithm/transform.cpp  ]
      [ run algorithm/upper_bound.cpp  ]
    ;

test-suite numeric
    : 
      [ run numeric/accumulate.cpp  ]
    ;

test-suite view
    : 
      [ run view/adjacent_filter.cpp  ]
      [ run view/as_range.cpp  ]
      [ run view/counted.cpp  ]
      [ run view/delimit.cpp  ]
      [ run view/indirect.cpp  ]
      [ run view/keys_value.cpp  ]
      [ run view/move.cpp  : : : : view_move ]
      [ run view/repeat.cpp  ]
      [ run view/replace_if.cpp  ]
      [ run view/replace.cpp  ]
      [ run view/slice.cpp  ]
      [ run view/unique.cpp  ]
      [ run view/zip.cpp  ]
    ;

explicit fix ;
test-suite fix
    : 
    ;
